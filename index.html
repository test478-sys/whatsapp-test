<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WhatsApp-ish Chat</title>
  <link rel="stylesheet" href="wa.css" />
  <!-- Supabase JS v2 -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div id="app" class="app">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="brand">
        <div class="brand-icon">W</div>
        <div>
          <div class="brand-title">WhatsApp-ish</div>
          <div class="brand-sub">Supabase · Realtime</div>
        </div>
      </div>

      <!-- Login / Profile -->
      <div class="auth">
        <label class="label">Choose a username</label>
        <div class="row">
          <input id="usernameInput" class="input" placeholder="e.g. raymond" />
          <button id="loginBtn" class="btn">Use</button>
        </div>
        <p class="muted">Unique across the app. Reuse to “sign back in”.</p>
        <div id="meTag" class="me hidden">
          Signed in as <span id="meName" class="me-name"></span>
        </div>
      </div>

      <!-- Search -->
      <div class="search">
        <input id="searchInput" class="input" placeholder="Search users…" />
      </div>

      <!-- User list -->
      <div id="userList" class="user-list"></div>

      <!-- Footer -->
      <div class="footer">
        Presence: <span id="presenceCount">0</span> online
      </div>
    </aside>

    <!-- Chat pane -->
    <main class="chat">
      <!-- Header -->
      <header class="chat-header">
        <div id="chatAvatar" class="avatar">?</div>
        <div class="chat-headings">
          <div id="chatTitle" class="chat-title">No chat selected</div>
          <div id="chatSubtitle" class="chat-subtitle">Select a user to start messaging</div>
        </div>
      </header>

      <!-- Messages -->
      <section id="messages" class="messages">
        <!-- bubbles injected here -->
      </section>

      <!-- Composer -->
      <footer class="composer">
        <form id="composer" class="composer-row">
          <input id="messageInput" class="input input-round" placeholder="Type a message" autocomplete="off" disabled />
          <button class="btn btn-send" disabled id="sendBtn">Send</button>
        </form>
      </footer>
    </main>
  </div>

  <script>
    // ----- SUPABASE CONFIG (your actual project) -----
    const SUPABASE_URL  = "https://czkbjqoxiynoajfftoyq.supabase.co";
    const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN6a2JqcW94aXlub2FqZmZ0b3lxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNzUxOTMsImV4cCI6MjA3MzY1MTE5M30.0sBWp1GLgrnD_6gsKB4L923bFCVAHcLWuq-5U0SRgi8";

    // Create client (ensure URL includes https:// and no extra spaces)
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);

    // ----- STATE -----
    let me = JSON.parse(localStorage.getItem("wa_me") || "null"); // { id, username }
    let users = [];              // list of other users
    let activePeer = null;       // user object for the open chat
    let msgChannel = null;       // realtime channel for messages
    let presenceChannel = null;  // realtime presence

    // ----- DOM -----
    const $ = (id) => document.getElementById(id);
    const usernameInput = $("usernameInput");
    const loginBtn = $("loginBtn");
    const meTag = $("meTag");
    const meName = $("meName");
    const userList = $("userList");
    const searchInput = $("searchInput");
    const messagesEl = $("messages");
    const chatTitle = $("chatTitle");
    const chatSubtitle = $("chatSubtitle");
    const chatAvatar = $("chatAvatar");
    const messageInput = $("messageInput");
    const sendBtn = $("sendBtn");
    const presenceCount = $("presenceCount");

    // ----- HELPERS -----
    const avatarInitial = (name) => (name?.[0] || "?").toUpperCase();
    const timeShort = (iso) => new Date(iso).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });

    function enableComposer(on) {
      messageInput.disabled = !on;
      sendBtn.disabled = !on;
    }

    function scrollMessagesToBottom() {
      messagesEl.scrollTop = messagesEl.scrollHeight; // element-only scroll (page stays fixed)
    }

    function setMe(u) {
      me = u;
      localStorage.setItem("wa_me", JSON.stringify(me));
      meName.textContent = me.username;
      meTag.classList.remove("hidden");
      usernameInput.value = me.username;
    }

    function setActivePeer(u) {
      activePeer = u;
      chatTitle.textContent = u ? u.username : "No chat selected";
      chatSubtitle.textContent = u ? "Direct messages" : "Select a user to start messaging";
      chatAvatar.textContent = avatarInitial(u?.username);
      chatAvatar.classList.toggle("avatar-on", !!u);
      messagesEl.innerHTML = "";
      enableComposer(!!u && !!me);
      if (u && me) {
        loadConversation(me.id, u.id);
        subscribeMessages(); // subscribe to inserts; filter client-side
      } else {
        unsubscribeMessages();
      }
    }

    function bubble({mine, text, at}) {
      const wrap = document.createElement("div");
      wrap.className = `row ${mine ? "right" : "left"}`;
      const b = document.createElement("div");
      b.className = `bubble ${mine ? "mine" : "theirs"}`;
      const p = document.createElement("div"); p.textContent = text;
      const meta = document.createElement("div"); meta.className = "meta"; meta.textContent = timeShort(at);
      b.appendChild(p); b.appendChild(meta);
      wrap.appendChild(b);
      return wrap;
    }

    function renderMessages(rows) {
      messagesEl.innerHTML = "";
      rows.forEach(r => {
        messagesEl.appendChild(bubble({
          mine: r.sender_id === me.id,
          text: r.content,
          at: r.created_at
        }));
      });
      scrollMessagesToBottom();
    }

    async function loadUsers() {
      const q = searchInput.value?.trim();
      let query = supabase.from('users').select('*').order('username', { ascending: true }).limit(200);
      if (q) query = query.ilike('username', `%${q}%`);
      const { data, error } = await query;
      if (error) { console.error(error); return; }
      users = (data || []).filter(u => me ? u.id !== me.id : true);
      drawUserList();
      renderPresenceBadges(); // refresh online badges after list changes
    }

    function drawUserList() {
      userList.innerHTML = "";
      if (!users.length) {
        userList.innerHTML = `<div class="empty">No users yet. Ask a friend to pick a username, or search again.</div>`;
        return;
      }
      users.forEach(u => {
        const row = document.createElement("button");
        row.className = "user-row";
        row.innerHTML = `
          <div class="avatar small">${avatarInitial(u.username)}</div>
          <div class="u-meta">
            <div class="u-name">${u.username} <span id="presence-${u.id}" class="badge hidden">online</span></div>
            <div class="u-sub">Tap to chat</div>
          </div>
        `;
        row.addEventListener("click", () => setActivePeer(u));
        userList.appendChild(row);
      });
    }

    async function ensureUsername(name) {
      name = (name || "").trim().toLowerCase();
      if (!name || name.length < 2) throw new Error("Username must be at least 2 characters.");
      // Try insert; on unique violation, fetch existing
      const insert = await supabase.from('users').insert({ username: name }).select().single();
      if (insert.data) return insert.data;
      const { data, error } = await supabase.from('users').select('*').eq('username', name).single();
      if (error || !data) throw (insert.error || error || new Error("Unable to claim username"));
      return data;
    }

    async function loadConversation(aId, bId) {
      const { data, error } = await supabase
        .from('messages')
        .select('*')
        .or(`and(sender_id.eq.${aId},recipient_id.eq.${bId}),and(sender_id.eq.${bId},recipient_id.eq.${aId})`)
        .order('created_at', { ascending: true })
        .limit(500);
      if (error) { console.error(error); return; }
      renderMessages(data || []);
    }

    async function sendMessage(text) {
      if (!me || !activePeer) return;
      const payload = { sender_id: me.id, recipient_id: activePeer.id, content: text };
      const { error } = await supabase.from('messages').insert(payload);
      if (error) { console.error(error); alert("Failed to send message."); }
    }

    function unsubscribeMessages() {
      if (msgChannel) {
        supabase.removeChannel(msgChannel);
        msgChannel = null;
      }
    }

    function subscribeMessages() {
      // Subscribe to all message inserts; filter in callback for simplicity/compat.
      unsubscribeMessages();
      msgChannel = supabase
        .channel('messages_inserts')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, (payload) => {
          if (!me || !activePeer) return;
          const r = payload.new;
          const isThisDM =
            (r.sender_id === me.id && r.recipient_id === activePeer.id) ||
            (r.sender_id === activePeer.id && r.recipient_id === me.id);
          if (!isThisDM) return;

          messagesEl.appendChild(bubble({
            mine: r.sender_id === me.id,
            text: r.content,
            at: r.created_at
          }));
          scrollMessagesToBottom();
        })
        .subscribe();
    }

    // Presence (not tied to Auth)
    function setupPresence() {
      if (presenceChannel) supabase.removeChannel(presenceChannel);
      const presenceKey = me?.id || `guest-${crypto.randomUUID()}`;
      presenceChannel = supabase.channel('presence', { config: { presence: { key: presenceKey } } });

      presenceChannel.on('presence', { event: 'sync' }, renderPresenceBadges);

      presenceChannel.subscribe((status) => {
        if (status === 'SUBSCRIBED' && me) {
          presenceChannel.track({ username: me.username });
        }
      });
    }

    function presenceState() {
      return presenceChannel ? (presenceChannel.presenceState() || {}) : {};
    }

    function renderPresenceBadges() {
      const state = presenceState(); // { "<key>": [{username: "..."}], ... }
      const onlineKeys = Object.keys(state);
      presenceCount.textContent = onlineKeys.length;
      users.forEach(u => {
        const el = document.getElementById(`presence-${u.id}`);
        if (!el) return;
        const isOnline = !!state[u.id]; // presence key equals user.id for logged-in users
        el.classList.toggle("hidden", !isOnline);
      });
    }

    // Events
    loginBtn.addEventListener("click", async () => {
      try {
        const u = await ensureUsername(usernameInput.value);
        setMe(u);
        await loadUsers();
        setupPresence();
        enableComposer(!!activePeer);
      } catch (e) {
        alert(e.message || "Unable to set username.");
      }
    });

    searchInput.addEventListener("input", () => {
      clearTimeout(searchInput._t);
      searchInput._t = setTimeout(loadUsers, 200);
    });

    $("composer").addEventListener("submit", async (e) => {
      e.preventDefault();
      const text = messageInput.value.trim();
      if (!text) return;
      messageInput.value = "";
      await sendMessage(text);
    });

    // Boot
    (async function init() {
      if (me) setMe(me);
      await loadUsers();
      setupPresence();
      enableComposer(false);
    })();
  </script>
</body>
</html>
