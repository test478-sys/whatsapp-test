<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WhatsApp-ish Chat</title>
  <link rel="stylesheet" href="wa.css" />
  <!-- Supabase JS v2 -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div id="app" class="app">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="brand">
        <div class="brand-icon">W</div>
        <div>
          <div class="brand-title">WhatsApp-ish</div>
          <div class="brand-sub">Supabase · Realtime</div>
        </div>
      </div>

      <!-- Login / Profile -->
      <div class="auth">
        <label class="label">Choose a username</label>
        <div class="row">
          <input id="usernameInput" class="input" placeholder="e.g. raymond" />
          <button id="loginBtn" class="btn">Use</button>
        </div>
        <p class="muted">Unique across the app. Reuse to “sign back in”.</p>
        <div id="meTag" class="me hidden">
          Signed in as <span id="meName" class="me-name"></span>
        </div>
      </div>

      <!-- Search -->
      <div class="search">
        <input id="searchInput" class="input" placeholder="Search users…" />
      </div>

      <!-- User list -->
      <div id="userList" class="user-list"></div>

      <!-- Footer -->
      <div class="footer">
        Presence: <span id="presenceCount">0</span> online
      </div>
    </aside>

    <!-- Chat pane -->
    <main class="chat">
      <!-- Header -->
      <header class="chat-header">
        <div id="chatAvatar" class="avatar">?</div>
        <div class="chat-headings">
          <div id="chatTitle" class="chat-title">No chat selected</div>
          <div id="chatSubtitle" class="chat-subtitle">Select a user to start messaging</div>
        </div>
      </header>

      <!-- Messages -->
      <section id="messages" class="messages">
        <!-- bubbles injected here -->
      </section>

      <!-- Composer -->
      <footer class="composer">
        <form id="composer" class="composer-row">
          <input id="messageInput" class="input input-round" placeholder="Type a message" autocomplete="off" disabled />
          <button class="btn btn-send" disabled id="sendBtn">Send</button>
        </form>
      </footer>
    </main>
  </div>

  <script>
    // ----- SUPABASE CONFIG (your actual project) -----
    const SUPABASE_URL  = "https://czkbjqoxiynoajfftoyq.supabase.co";
    const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN6a2JqcW94aXlub2FqZmZ0b3lxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNzUxOTMsImV4cCI6MjA3MzY1MTE5M30.0sBWp1GLgrnD_6gsKB4L923bFCVAHcLWuq-5U0SRgi8";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);

    // ----- STATE -----
    let me = JSON.parse(localStorage.getItem("wa_me") || "null"); // { id, username }
    let users = [];                     // other users
    let activePeer = null;              // open chat user
    let msgChannel = null;              // realtime channel
    let presenceChannel = null;         // presence channel
    let unreadCounts = {};              // { [userId]: number }
    let lastReads = {};                 // { [peerId]: isoString } per current me

    // ----- DOM -----
    const $ = (id) => document.getElementById(id);
    const usernameInput = $("usernameInput");
    const loginBtn = $("loginBtn");
    const meTag = $("meTag");
    const meName = $("meName");
    const userList = $("userList");
    const searchInput = $("searchInput");
    const messagesEl = $("messages");
    const chatTitle = $("chatTitle");
    const chatSubtitle = $("chatSubtitle");
    const chatAvatar = $("chatAvatar");
    const messageInput = $("messageInput");
    const sendBtn = $("sendBtn");
    const presenceCount = $("presenceCount");

    // ----- HELPERS -----
    const avatarInitial = (name) => (name?.[0] || "?").toUpperCase();
    const timeShort = (iso) => new Date(iso).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    const EPOCH = "1970-01-01T00:00:00.000Z";

    function readsKey() { return me ? `wa_reads_${me.id}` : "wa_reads_anon`; }
    function loadReads() {
      if (!me) { lastReads = {}; return; }
      try { lastReads = JSON.parse(localStorage.getItem(readsKey()) || "{}"); } catch { lastReads = {}; }
    }
    function saveReads() {
      if (!me) return;
      localStorage.setItem(readsKey(), JSON.stringify(lastReads));
    }
    function getLastRead(peerId) { return lastReads[peerId] || EPOCH; }
    function markRead(peerId) {
      lastReads[peerId] = new Date().toISOString();
      saveReads();
      unreadCounts[peerId] = 0;
      renderUnreadBadges();
    }

    function enableComposer(on) { messageInput.disabled = !on; sendBtn.disabled = !on; }
    function scrollMessagesToBottom() { messagesEl.scrollTop = messagesEl.scrollHeight; }

    function setMe(u) {
      me = u;
      localStorage.setItem("wa_me", JSON.stringify(me));
      meName.textContent = me.username;
      meTag.classList.remove("hidden");
      usernameInput.value = me.username;
      loadReads();
    }

    function setActivePeer(u) {
      activePeer = u;
      chatTitle.textContent = u ? u.username : "No chat selected";
      chatSubtitle.textContent = u ? "Direct messages" : "Select a user to start messaging";
      chatAvatar.textContent = avatarInitial(u?.username);
      chatAvatar.classList.toggle("avatar-on", !!u);
      messagesEl.innerHTML = "";
      enableComposer(!!u && !!me);

      if (u && me) {
        loadConversation(me.id, u.id).then(() => {
          // When you open a chat, mark it read
          markRead(u.id);
        });
        subscribeMessages(); // inserts across table; we'll filter per event
      } else {
        unsubscribeMessages();
      }
    }

    function bubble({mine, text, at}) {
      const wrap = document.createElement("div");
      wrap.className = `row ${mine ? "right" : "left"}`;
      const b = document.createElement("div");
      b.className = `bubble ${mine ? "mine" : "theirs"}`;
      const p = document.createElement("div"); p.textContent = text;
      const meta = document.createElement("div"); meta.className = "meta"; meta.textContent = timeShort(at);
      b.appendChild(p); b.appendChild(meta);
      wrap.appendChild(b);
      return wrap;
    }

    function renderMessages(rows) {
      messagesEl.innerHTML = "";
      rows.forEach(r => {
        messagesEl.appendChild(bubble({
          mine: r.sender_id === me.id,
          text: r.content,
          at: r.created_at
        }));
      });
      scrollMessagesToBottom();
    }

    async function loadUsers() {
      const q = searchInput.value?.trim();
      let query = supabase.from('users').select('*').order('username', { ascending: true }).limit(200);
      if (q) query = query.ilike('username', `%${q}%`);
      const { data, error } = await query;
      if (error) { console.error(error); return; }
      users = (data || []).filter(u => me ? u.id !== me.id : true);
      drawUserList();
      renderPresenceBadges();
      await refreshUnreadCounts();  // compute & paint unread after list loads
    }

    function drawUserList() {
      userList.innerHTML = "";
      if (!users.length) {
        userList.innerHTML = `<div class="empty">No users yet. Ask a friend to pick a username, or search again.</div>`;
        return;
      }
      users.forEach(u => {
        const row = document.createElement("button");
        row.className = "user-row";
        row.innerHTML = `
          <div class="avatar small">${avatarInitial(u.username)}</div>
          <div class="u-meta">
            <div class="u-name">
              ${u.username}
              <span id="unread-${u.id}" class="badge-unread hidden">0</span>
              <span id="presence-${u.id}" class="badge hidden">online</span>
            </div>
            <div class="u-sub">Tap to chat</div>
          </div>
        `;
        row.addEventListener("click", () => setActivePeer(u));
        userList.appendChild(row);
      });
      renderUnreadBadges();
    }

    async function ensureUsername(name) {
      name = (name || "").trim().toLowerCase();
      if (!name || name.length < 2) throw new Error("Username must be at least 2 characters.");
      const insert = await supabase.from('users').insert({ username: name }).select().single();
      if (insert.data) return insert.data;
      const { data, error } = await supabase.from('users').select('*').eq('username', name).single();
      if (error || !data) throw (insert.error || error || new Error("Unable to claim username"));
      return data;
    }

    async function loadConversation(aId, bId) {
      const { data, error } = await supabase
        .from('messages')
        .select('*')
        .or(`and(sender_id.eq.${aId},recipient_id.eq.${bId}),and(sender_id.eq.${bId},recipient_id.eq.${aId})`)
        .order('created_at', { ascending: true })
        .limit(500);
      if (error) { console.error(error); return; }
      renderMessages(data || []);
    }

    async function sendMessage(text) {
      if (!me || !activePeer) return;
      const payload = { sender_id: me.id, recipient_id: activePeer.id, content: text };
      const { error } = await supabase.from('messages').insert(payload);
      if (error) { console.error(error); alert("Failed to send message."); }
    }

    function unsubscribeMessages() {
      if (msgChannel) {
        supabase.removeChannel(msgChannel);
        msgChannel = null;
      }
    }

    function subscribeMessages() {
      unsubscribeMessages();
      msgChannel = supabase
        .channel('messages_inserts')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, (payload) => {
          if (!me) return;
          const r = payload.new;

          // If a new message is addressed to me and NOT the open chat, bump unread
          if (r.recipient_id === me.id && (!activePeer || r.sender_id !== activePeer.id)) {
            unreadCounts[r.sender_id] = (unreadCounts[r.sender_id] || 0) + 1;
            updateUnreadBadge(r.sender_id);
          }

          // If it's part of the open DM, render bubble + keep read
          if (activePeer) {
            const isThisDM =
              (r.sender_id === me.id && r.recipient_id === activePeer.id) ||
              (r.sender_id === activePeer.id && r.recipient_id === me.id);
            if (isThisDM) {
              messagesEl.appendChild(bubble({
                mine: r.sender_id === me.id,
                text: r.content,
                at: r.created_at
              }));
              scrollMessagesToBottom();
              // mark read for active conversation
              if (r.sender_id === activePeer.id) markRead(activePeer.id);
            }
          }
        })
        .subscribe();
    }

    // Presence (not tied to Auth)
    function setupPresence() {
      if (presenceChannel) supabase.removeChannel(presenceChannel);
      const presenceKey = me?.id || `guest-${crypto.randomUUID()}`;
      presenceChannel = supabase.channel('presence', { config: { presence: { key: presenceKey } } });

      presenceChannel.on('presence', { event: 'sync' }, renderPresenceBadges);

      presenceChannel.subscribe((status) => {
        if (status === 'SUBSCRIBED' && me) {
          presenceChannel.track({ username: me.username });
        }
      });
    }

    function presenceState() { return presenceChannel ? (presenceChannel.presenceState() || {}) : {}; }

    function renderPresenceBadges() {
      const state = presenceState(); // { "<key>": [{username: "..."}], ... }
      const onlineKeys = Object.keys(state);
      presenceCount.textContent = onlineKeys.length;
      users.forEach(u => {
        const el = document.getElementById(`presence-${u.id}`);
        if (!el) return;
        const isOnline = !!state[u.id];
        el.classList.toggle("hidden", !isOnline);
      });
    }

    // -------- UNREAD COUNTS --------
    function updateUnreadBadge(peerId) {
      const n = unreadCounts[peerId] || 0;
      const el = document.getElementById(`unread-${peerId}`);
      if (!el) return;
      if (n > 0) {
        el.textContent = n > 99 ? "99+" : String(n);
        el.classList.remove("hidden");
      } else {
        el.classList.add("hidden");
      }
    }

    function renderUnreadBadges() {
      users.forEach(u => updateUnreadBadge(u.id));
    }

    function minLastReadForAll() {
      const vals = Object.values(lastReads);
      if (!vals.length) return EPOCH;
      let min = vals[0];
      for (const v of vals) if (new Date(v) < new Date(min)) min = v;
      return min;
    }

    // Pull all messages to me since the earliest lastRead, then count per-sender in JS
    async function refreshUnreadCounts() {
      if (!me) return;
      // init zero for all list users so badges hide if none
      users.forEach(u => unreadCounts[u.id] = 0);

      const since = minLastReadForAll();
      const { data, error } = await supabase
        .from('messages')
        .select('sender_id, recipient_id, created_at')
        .eq('recipient_id', me.id)
        .gt('created_at', since)
        .order('created_at', { ascending: false })
        .limit(2000); // demo-safe; raise if you expect heavy traffic
      if (error) { console.error(error); renderUnreadBadges(); return; }

      for (const m of (data || [])) {
        // Only count if it's newer than this sender's lastRead
        if (new Date(m.created_at) > new Date(getLastRead(m.sender_id))) {
          unreadCounts[m.sender_id] = (unreadCounts[m.sender_id] || 0) + 1;
        }
      }
      renderUnreadBadges();
    }

    // -------- Events --------
    loginBtn.addEventListener("click", async () => {
      try {
        const u = await ensureUsername(usernameInput.value);
        setMe(u);
        await loadUsers();
        setupPresence();
        enableComposer(!!activePeer);
        await refreshUnreadCounts();
      } catch (e) {
        alert(e.message || "Unable to set username.");
      }
    });

    searchInput.addEventListener("input", () => {
      clearTimeout(searchInput._t);
      searchInput._t = setTimeout(loadUsers, 200);
    });

    $("composer").addEventListener("submit", async (e) => {
      e.preventDefault();
      const text = messageInput.value.trim();
      if (!text) return;
      messageInput.value = "";
      await sendMessage(text);
    });

    // Boot
    (async function init() {
      if (me) setMe(me);
      await loadUsers();
      setupPresence();
      enableComposer(false);
      await refreshUnreadCounts();
    })();
  </script>
</body>
</html>
